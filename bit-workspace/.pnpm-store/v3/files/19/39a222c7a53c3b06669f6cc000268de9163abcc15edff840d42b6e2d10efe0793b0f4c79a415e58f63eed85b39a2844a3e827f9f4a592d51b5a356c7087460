import { relative, resolve, sep } from 'path';
import { existsSync, writeJSONSync } from 'fs-extra';
import minimatch from 'minimatch';
import { compact, flatten, isEmpty } from 'lodash';
import {
  TesterContext,
  Tests,
  ComponentPatternsEntry,
  ComponentsResults,
} from '@teambit/tester';
import { TestsFiles, TestResult, TestsResult } from '@teambit/tests-results';
import { Component, ComponentMap } from '@teambit/component';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import esmLoader from '@teambit/node.utils.esm-loader';
import type { Vitest } from  'vitest/node';
import { pathToFileURL, fileURLToPath } from 'url';
import type { InlineConfig as ViteConfig } from 'vite';
import { resolve as resolveEsm } from 'mlly';
import { VitestError } from './vitest-error';
import { VitestTesterOptions } from './vitest-options';

const getVite = async (rootPath: string) => {
  const rootPathUrl = pathToFileURL(rootPath);
  const path = await resolveEsm('vite', {
    url: rootPathUrl
  });
  if (!path) throw new Error('[vitest-tester]: `vite` is required to be installed')
  const vite = await esmLoader(fileURLToPath(path));
  return vite;
};

// types

// https://stackoverflow.com/a/51399781
type ArrayElement<ArrayType extends readonly unknown[]> = 
  ArrayType extends readonly (infer ElementType)[] ? ElementType : never;

export type VitestFile = ArrayElement<ReturnType<Vitest['state']['getFiles']>>;

type VitestTask = ArrayElement<VitestFile['tasks']>;

type VitestErrorWithDiff = ArrayElement<NonNullable<NonNullable<VitestTask['result']>['errors']>>;

type VitestTaskState = 'run' | 'skip' | 'only' | 'todo' | 'pass' | 'fail';

// pattern utils

const resolvePattern = (pattern: string, rootDirs: string[]) => {
  return rootDirs.map((dir) => resolve(dir, pattern));
}

const resolvePatternEntry = (patternEntry: ComponentPatternsEntry) => {
  const { componentDir, paths } = patternEntry;
  return paths.map((p) => {
    if (p.relative.startsWith('!')) {
      return `!${componentDir}${p.relative.slice(1)}`;
    }
    return resolve(componentDir, p.path)
  });
}

const resolveComponentPattern = (
  component: Component,
  patternEntry: ComponentPatternsEntry,
  opts: VitestTesterOptions,
  context: TesterContext
): string[] => {
  if (opts.resolveSpecPaths) {
    return opts.resolveSpecPaths(component, context);
  }
  const customPatterns = opts.patterns;
  // If pattern were provided to the specific instance of the tester, use them
  if (customPatterns && !isEmpty(customPatterns)) {
    customPatterns.map((customPattern) => {
      const rootDirs = opts.roots || [patternEntry.componentDir];
      return resolvePattern(customPattern, rootDirs);
    });
  }

  const resolvedPatterns = resolvePatternEntry(patternEntry);
  return resolvedPatterns;
}

// input utils

export const patternsToArray = (
  opts: VitestTesterOptions,
  context: TesterContext
): string[] => {
  const patternArray = flatten(
    context.patterns
      .toArray()
      .map(([component, patternEntry]) =>
        resolveComponentPattern(component, patternEntry, opts, context)
      )
  );
  if (sep === '\\') {
    return patternArray.map((pattern) => pattern.replace(/\\/g, '/'));
  }
  return patternArray;
}

const ensurePackageJson = (dir: string) => {
  const packageJsonPath = resolve(dir, 'package.json');
  if (!existsSync(packageJsonPath)) {
    writeJSONSync(packageJsonPath, {});
  }
}

export const getConfig = async (configPath: string, context: TesterContext, depResolver: DependencyResolverMain, watch?: boolean): Promise<ViteConfig> => {
  const packageNames = context.components.map((component) => depResolver.getPackageName(component));
  const defaultExclude = [
    '**/node_modules/**',
    '**/cypress/**',
    '**/.{idea,git,cache,output,temp}/**',
    '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*'
  ];
  
  // TODO: remove this once we have a better way to handle this
  ensurePackageJson(context.rootPath);

  const config: ViteConfig = {
    root: context.rootPath,
    configFile: false,
    envFile: false,
    plugins: [],
    server: {
      fs: {
        strict: false
      },
      watch: {
        ignored: packageNames.map((m) => `!**/node_modules/${m}/**`),
      }
    },
    cacheDir: resolve(context.rootPath, 'node_modules', '.vitest'),
    test: {
      globals: true,
      environment: 'jsdom',
      root: context.rootPath,
      exclude: defaultExclude,
      testTimeout: 10000,
      server: {
        deps: {
          // @ts-ignore
          // web: {
          //   transformCss: true,
          //   transformAssets: true
          // },  
          inline: [/^(?!.*vitest).*$/],
        }
      },
    }
  };

  if (context.debug) {
    // Nothing to do with Vitest
  }
  if (context.coverage) {
    config.test!.coverage = {
      provider: 'v8',
      enabled: true,
    };
  }
  config.test!.watch = context.watch || watch;

  const { mergeConfig, loadConfigFromFile } = await getVite(context.rootPath);
  const vitestConfig = await loadConfigFromFile({
    command: 'build',
    mode: 'development'
  }, configPath)
  const realVitestConfig: ViteConfig = vitestConfig?.config || {};
  const result = mergeConfig(config, realVitestConfig);
  return result;
};

// output utils

const getTaskState = (status: VitestTaskState | undefined): TestResult["status"] => {
  switch (status) {
    case 'pass':
      return 'passed';
    case 'fail':
      return 'failed';
    case 'skip':
      return 'skipped';
    case 'todo':
      return 'todo';
    default:
      return 'pending';
  }
}

const traverseTask = (task: VitestTask, ancestor: string[] = []) => {
  const resultList: TestResult[] = [];
  const errorList: VitestErrorWithDiff[] = [];
  const info = {
    resultList,
    pass: 0,
    failed: 0,
    pending: 0,
    duration: 0,
    slow: false, // TODO: calculate slow
    errorList,
  };
  if (task.type === 'test') {
    const error = task.result?.errors?.[0];
    const errorStr = error?.message || error?.stack;
    const status = getTaskState(task.result?.state);
    switch (status) {
      case 'passed':
        info.pass += 1;
        break;
      case 'failed':
        info.failed += 1;
        break;
      case 'pending':
        info.pending += 1;
        break;
      default:
        break;
    }
    const isFailure = status === 'failed';
    info.duration += task.result?.duration || 0;
    resultList.push(new TestResult(
      ancestor,
      task.name,
      status,
      task.result?.duration,
      isFailure ? undefined : errorStr,
      isFailure ? errorStr : undefined
    ));
  }
  if (task.type === 'suite') {
    errorList.push(...(task.result?.errors || []));
    task.tasks.forEach(subTask => {
      const subInfo = traverseTask(subTask, [...ancestor]);
      info.pass += subInfo.pass;
      info.failed += subInfo.failed;
      info.pending += subInfo.pending;
      info.duration += subInfo.duration;
      info.slow = info.slow || subInfo.slow;
      resultList.push(...subInfo.resultList);
      errorList.push(...subInfo.errorList);
    });
  }
  return info;
}

const genErrorsFromTests = (files: TestsFiles[], unhandledErrors: unknown[]): VitestError[] => {
  const errors: VitestError[] = [];
  files.forEach(file => {
    file.tests.forEach(test => {
      if (test.error) {
        errors.push(new VitestError(test.error));
      }

      if (test.failure) {
        errors.push(new VitestError(test.failure));
      }
    });
  });
  unhandledErrors.forEach((error) => {
    errors.push(error as Error);
  });
  return errors;
};

export const getResultFromFiles = (
  files: VitestFile[],
  errors: unknown[],
  opts: VitestTesterOptions,
  testerContext: TesterContext
): Tests => {
  const componentMap = ComponentMap.as(testerContext.patterns.components, (component) => {
    const componentPatternValue = testerContext.patterns.get(component);
    if (!componentPatternValue) return [];
    const [currComponent, patternEntry] = componentPatternValue;
    const resolvedPatterns = resolveComponentPattern(
      currComponent,
      patternEntry,
      opts,
      testerContext
    );
    return files.filter(
      file =>
        resolvedPatterns.filter((resolvedPattern) =>
          minimatch(file.filepath, resolvedPattern)
        ).length > 0
    );
  });

  const componentResults = componentMap.toArray().map(([component, componentFiles]) => {
    const componentPatternValue = testerContext.patterns.get(component);
    if (!componentPatternValue) return undefined;
    const [, patternEntry] = componentPatternValue;
    const tests: TestsFiles[] = [];
    const fileErrors: Error[] = [];

    componentFiles!.forEach(file => {
      const {
        pass,
        failed,
        pending,
        duration,
        slow,
        resultList,
        errorList,
      } = traverseTask(file);

      let fileError: Error | undefined;
      if (errorList.length > 0) {
        fileError = new Error(errorList.map(e => e.stackStr || '').join('\n'))
        fileErrors.push(fileError);
      }

      tests.push(new TestsFiles(
        relative(patternEntry.componentDir, file.filepath),
        resultList,
        pass,
        failed,
        pending,
        duration,
        slow,
        fileError
      ));
    });

    const totalErrors = genErrorsFromTests(tests, [...errors, ...fileErrors]);

    return {
      componentId: component.id,
      results: new TestsResult(tests, totalErrors.length === 0, 0),
      errors: totalErrors,
    } as ComponentsResults;
  });

  const result = compact(componentResults);
  return new Tests(result);
}
